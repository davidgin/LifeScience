# LifeScience

Welcome to **LifeScience**, a Golang-based REST API designed for logging and retrieving life sciences video annotations with geospatial data integration. This project simulates a data engineering workflow, tracking events such as video recordings of biological experiments, enriched with location data from OpenStreetMap (OSM) and stored in a PostgreSQL database. It’s containerized with Docker for easy deployment and demonstrates concurrency, database interactions, and external API usage. LifeScience was developed as a proof-of-concept for a life sciences data engineering pipeline. It evolved over 23 commits spanning from March 6, 2022, to March 6, 2025, showcasing incremental feature additions like PostgreSQL persistence, OSM geospatial lookups, and Docker support. The project is ideal for learning about RESTful services, database integration, and containerization in a scientific context. Its features include REST API endpoints (`POST /api/v1/events` to create events and `GET /api/v1/events` to retrieve them), PostgreSQL with `sqlx` for structured storage, OSM integration with retry logic, goroutines for async operations, Docker and Docker Compose for containerization, and dependency management with Go modules. To run LifeScience, ensure you have Go 1.21+ (`go version`), Docker with Compose (`docker --version`, `docker-compose --version`), Git (`git --version`), and internet access for OSM and Docker pulls. Installation starts with cloning the repository using `git clone https://github.com/davidgin/LifeScience.git` followed by `cd LifeScience`. Step 2 involves building and running with Docker: build the application with `docker-compose build` (which uses the `Dockerfile` to create the Go app image), start all services with `docker-compose up` (launching the API at `http://localhost:8080` and PostgreSQL at `localhost:5432`; use `docker-compose up -d` for background mode), and stop services with `docker-compose down` (add `--volumes` to clear PostgreSQL data). Step 3 covers running locally without Docker: install Go dependencies with `go mod download` (fetching `gin-gonic/gin`, `jmoiron/sqlx`, and `lib/pq`), set up PostgreSQL by installing it (e.g., `brew install postgresql` on macOS or `apt install postgresql` on Ubuntu), starting the service (`pg_ctl start` or `systemctl start postgresql`), and creating a user and database with `psql -c "CREATE USER life_user WITH PASSWORD 'life_pass123';"` and `psql -c "CREATE DATABASE life_science_db OWNER life_user;"`, then launch the app with `go run main.go` (runs on `http://localhost:8080`, stop with `Ctrl+C`). Usage includes creating an event with `curl -X POST http://localhost:8080/api/v1/events -H "Content-Type: application/json" -d '{"title": "Frog Dissection", "description": "Lab experiment video", "video_url": "https://example.com/frog.mp4"}'` (submits an event; the API adds `id`, `timestamp`, and fetches `location` from OSM, returning a JSON response like `{"id": 1, "title": "Frog Dissection", "description": "Lab experiment video", "timestamp": "2025-03-06T12:00:00Z", "processed": false, "location": "Unknown Location", "video_url": "https://example.com/frog.mp4"}`), retrieving events with `curl http://localhost:8080/api/v1/events` (returns a JSON array of events in descending timestamp order, e.g., `[{"id": 1, "title": "Frog Dissection", "description": "Lab experiment video", "timestamp": "2025-03-06T12:00:00Z", "processed": false, "location": "Unknown Location", "video_url": "https://example.com/frog.mp4"}]`), and error handling where invalid JSON returns `400 Bad Request` with `{"error": "parsing error"}` and database issues return `500 Internal Server Error` with `{"error": "db error"}`. The project structure consists of `LifeScience/` containing `main.go` (entry point: initializes Gin router and starts server), `models.go` (defines `Event` struct with JSON and DB tags), `handlers.go` (contains `CreateEvent` and `GetEvents` handlers with goroutines), `db.go` (manages PostgreSQL connection and table creation via `sqlx`), `osm.go` (implements OSM client and `FetchOSMLocationWithRetry`), `Dockerfile` (multi-stage build for Go app from Golang 1.21 to Alpine), `docker-compose.yml` (configures API and PostgreSQL services with networking), `go.mod` (lists dependencies: `gin`, `sqlx`, `pq`), and `go.sum` (ensures dependency integrity with checksums). Contributing to LifeScience is encouraged—fork the repo by clicking "Fork" on GitHub or using `git clone https://github.com/<your-username>/LifeScience.git`, create a branch with `git checkout -b feature/your-feature-name` (e.g., `feature/add-authentication`), make changes and test locally (e.g., `go run main.go` or `docker-compose up`), commit with `git add .` and `git commit -m "Implement your feature with details"`, push with `git push origin feature/your-feature-name`, and submit a PR by going to `https://github.com/davidgin/LifeScience`, clicking "Pull Requests," then "New Pull Request." Guidelines include keeping code consistent with existing style (e.g., Go fmt), adding tests if possible (future enhancement), and describing changes clearly in the PR. The project is licensed under the MIT License (to be added in a `LICENSE` file). For questions or support, reach out to [davidgin](https://github.com/davidgin) via GitHub Issues. Happy coding with LifeScience!
